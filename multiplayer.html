        function handleMultiplayerCellClick(event) {
            // Only allow clicks during player's turn, not game over, and directly on a cell
            // Check processingMove flag to prevent multiple clicks during transaction
            if (!multiplayerTurn || gameOver || processingMove || !event.target.classList.contains('cell')) return;

            const cell = event.target;
            const row = parseInt(cell.dataset.row);
            const col = parseInt(cell.dataset.col);

            // Determine the action based on the game phase
            const action = isRemovalPhase ? 'remove' : 'place';
            const symbol = isPlayerX ? 'X' : 'O'; // Symbol this player uses

            // Set processing flag to prevent further clicks until transaction completes/fails
            processingMove = true;
            updateMessage("Processing move..."); // Give user feedback

            // Submit the move to Firebase via transaction
            submitMultiplayerMove(row, col, symbol, action)
                .then(committed => {
                    if (committed) {
                        // Move was successful, Firebase listeners will update UI
                        updateMessage(""); // Clear processing message
                    } else {
                        // Transaction aborted (e.g., invalid move)
                        // Firebase listeners might update state if another player moved first
                        updateMessage("Move invalid or state changed."); // Inform user
                        setTimeout(() => updateMessage(""), 2000);
                    }
                })
                .catch(error => {
                    console.error("Firebase transaction failed:", error);
                    updateMessage("Error processing move. Try again.");
                    // Consider more robust error handling, e.g., re-syncing state
                })
                .finally(() => {
                    // Reset processing flag regardless of outcome
                    processingMove = false;
                    // Update turn indicator based on latest state (listeners might have updated it)
                    updateTurnIndicator();
                });
        }


        // --- New Function for Firebase Transaction ---
        function submitMultiplayerMove(row, col, playerSymbol, action) {
            const gameRef = database.ref(`games/${gameId}`);

            return gameRef.transaction(currentGameData => {
                // If game data doesn't exist (e.g., game deleted), abort.
                if (currentGameData === null) {
                    console.log("Transaction aborted: Game data is null.");
                    return undefined; // Abort transaction
                }

                // --- Transaction Validation ---
                // Check if game is already over
                if (currentGameData.gameOver) {
                    console.log("Transaction aborted: Game is over.");
                    return undefined;
                }
                // Check if it's the correct player's turn
                if (currentGameData.currentPlayer !== playerSymbol) {
                    console.log(`Transaction aborted: Not ${playerSymbol}'s turn (it's ${currentGameData.currentPlayer}).`);
                    return undefined;
                }
                 // Check if the action matches the current game phase
                if ((action === 'remove' && !currentGameData.isRemovalPhase) || (action === 'place' && currentGameData.isRemovalPhase)) {
                    console.log(`Transaction aborted: Action '${action}' invalid for current phase.`);
                    return undefined;
                }

                // --- Apply Move Logic ---
                let updatedGameData = { ...currentGameData }; // Create a mutable copy
                let scored = false;
                let winningCellsToClear = [];

                if (action === 'place') {
                    // Check if cell is already taken
                    if (updatedGameData.board[row][col] !== null) {
                        console.log("Transaction aborted: Cell already taken.");
                        return undefined;
                    }

                    // Place the piece
                    updatedGameData.board[row][col] = playerSymbol;

                    // Check for scoring (Connect 5 takes precedence)
                    const win5 = checkWinTransaction(updatedGameData.board, row, col, 5);
                    const win4 = !win5 ? checkWinTransaction(updatedGameData.board, row, col, 4) : null;

                    if (win5 || win4) {
                        scored = true;
                        const points = win5 ? CONNECT_5_POINTS : CONNECT_4_POINTS;
                        winningCellsToClear = win5 ? win5.cells : win4.cells;

                        updatedGameData.scores[playerSymbol] = (updatedGameData.scores[playerSymbol] || 0) + points;

                        // Check for game over
                        if (updatedGameData.scores[playerSymbol] >= WINNING_SCORE) {
                            updatedGameData.gameOver = true;
                        } else {
                            // Player gets another turn (bonus turn)
                            updatedGameData.currentPlayer = playerSymbol; // Stay on current player
                            // Clear winning cells (will be handled by listener based on winningCellsToClear)
                        }
                    } else {
                        // No score - check for board full
                        if (isBoardFullTransaction(updatedGameData.board)) {
                            updatedGameData.isRemovalPhase = true;
                            updatedGameData.removalTurnsLeft = REMOVAL_TURNS_EACH * 2;
                            updatedGameData.playerBeforeBoardFull = playerSymbol;
                            updatedGameData.currentPlayer = 'X'; // X always starts removal
                        } else {
                            // Switch player
                            updatedGameData.currentPlayer = playerSymbol === 'X' ? 'O' : 'X';
                        }
                    }
                } else { // action === 'remove'
                    const opponentSymbol = playerSymbol === 'X' ? 'O' : 'X';
                    // Check if the target cell has the opponent's piece
                    if (updatedGameData.board[row][col] !== opponentSymbol) {
                        console.log("Transaction aborted: Cannot remove that piece.");
                        return undefined;
                    }
                    // Check if removal turns are left
                    if (updatedGameData.removalTurnsLeft <= 0) {
                         console.log("Transaction aborted: No removal turns left.");
                         return undefined;
                    }

                    // Remove the piece
                    updatedGameData.board[row][col] = null;
                    updatedGameData.removalTurnsLeft--;

                    if (updatedGameData.removalTurnsLeft === 0) {
                        // End removal phase
                        updatedGameData.isRemovalPhase = false;
                        // Player who *didn't* play last before board full goes next
                        updatedGameData.currentPlayer = updatedGameData.playerBeforeBoardFull === 'X' ? 'O' : 'X';
                        updatedGameData.playerBeforeBoardFull = null;
                    } else {
                        // Switch player for next removal turn
                        updatedGameData.currentPlayer = opponentSymbol;
                    }
                }

                // --- Final Updates ---
                // Add a flag or data for listeners to handle clearing cells if a score happened
                updatedGameData.lastMove = { player: playerSymbol, scored: scored, cellsToClear: winningCellsToClear, timestamp: firebase.database.ServerValue.TIMESTAMP };

                // Return the updated game data to commit the transaction
                return updatedGameData;

            }, (error, committed, snapshot) => {
                // Transaction callback (optional but useful for debugging)
                if (error) {
                    console.error('Transaction failed abnormally!', error);
                } else if (!committed) {
                    console.log('Transaction aborted (e.g., data changed concurrently or validation failed).');
                    // Potentially check snapshot.val() for the current state
                } else {
                    console.log('Transaction committed successfully!');
                    // State updated, listeners will handle UI
                }
            });
        }

        // --- Helper functions for transaction logic (need to avoid global state) ---
        function checkWinTransaction(boardState, lastRow, lastCol, connectLength) {
             const player = boardState[lastRow][lastCol];
             if (!player) return null;
             const directions = [ { dr: 0, dc: 1 }, { dr: 1, dc: 0 }, { dr: 1, dc: 1 }, { dr: 1, dc: -1 } ];

             for (const { dr, dc } of directions) {
                 let count = 1;
                 let winningCells = [{ r: lastRow, c: lastCol }];
                 for (let i = 1; i < connectLength; i++) {
                     const r = lastRow + i * dr; const c = lastCol + i * dc;
                     if (r >= 0 && r < GRID_SIZE && c >= 0 && c < GRID_SIZE && boardState[r][c] === player) { count++; winningCells.push({ r, c }); } else break;
                 }
                 for (let i = 1; i < connectLength; i++) {
                     const r = lastRow - i * dr; const c = lastCol - i * dc;
                     if (r >= 0 && r < GRID_SIZE && c >= 0 && c < GRID_SIZE && boardState[r][c] === player) { count++; winningCells.push({ r, c }); } else break;
                 }
                 if (count === connectLength) { return { cells: winningCells }; }
             }
             return null;
         }

         function isBoardFullTransaction(boardState) {
            for (let r = 0; r < GRID_SIZE; r++) {
                for (let c = 0; c < GRID_SIZE; c++) {
                    if (boardState[r][c] === null) return false;
                }
            }
            return true;
         }

        // --- Modify Listeners to handle new structure and clearing ---
        function setupMultiplayerGameListeners() {
            // Keep track of all the listeners we set up
            const gameListeners = [];
            const gameRef = database.ref(`games/${gameId}`);

            // Listen for the entire game state object
            gameListeners.push(['gameState', gameRef.on('value', (snapshot) => {
                if (!snapshot.exists()) {
                    // Game might have been deleted or doesn't exist
                    console.log("Game data not found or deleted.");
                    if (multiplayerGameStarted) {
                        cleanupMultiplayerGame(); // Clean up local listeners
                        showPopupMessage("Game session ended or could not be found.")
                            .then(() => resetToLandingPage());
                    }
                    return;
                }

                const gameData = snapshot.val();

                // Update local state variables from Firebase data
                board = gameData.board || Array(GRID_SIZE).fill(null).map(() => Array(GRID_SIZE).fill(null)); // Handle potential null board
                currentPlayer = gameData.currentPlayer;
                scores = gameData.scores || { X: 0, O: 0 };
                isRemovalPhase = gameData.isRemovalPhase;
                removalTurnsLeft = gameData.removalTurnsLeft;
                gameOver = gameData.gameOver;
                playerBeforeBoardFull = gameData.playerBeforeBoardFull; // Needed for removal phase end logic locally

                // Update opponent name if we don't have it yet (relevant for player joining)
                const opponentRoleCheck = isPlayerX ? 'O' : 'X';
                if (gameData.players && gameData.players[opponentRoleCheck] && !opponentName) {
                    opponentName = gameData.players[opponentRoleCheck].name;
                    updatePlayerLabels(); // Update labels now that we have the name
                }

                // Determine whose turn it is locally
                multiplayerTurn = !gameOver && ((isPlayerX && currentPlayer === 'X') || (!isPlayerX && currentPlayer === 'O'));

                // Update UI based on the new state
                updateBoardUI(board); // Update the visual board
                updateScoreDisplay();
                updateTurnIndicator();
                gameContainerElement.classList.toggle('removal-phase', isRemovalPhase);

                // Handle Game Over state message
                if (gameOver) {
                    const winner = scores.X >= WINNING_SCORE ? 'X' : (scores.O >= WINNING_SCORE ? 'O' : null);
                    if (winner) {
                         const winnerName = winner === 'X' ? (isPlayerX ? playerName : opponentName) : (isPlayerX ? opponentName : playerName);
                         updateMessage(`${winnerName} wins! (${scores.X}-${scores.O})`);
                    } else {
                        // Handle potential draw or unexpected game over state
                        updateMessage("Game Over!");
                    }
                } else if (isRemovalPhase) {
                     updateMessage(`${multiplayerTurn ? 'Your turn' : opponentName + "'s turn"} to remove. (${removalTurnsLeft} left)`);
                } else {
                    updateMessage(""); // Clear message area during normal play
                }

                // Handle clearing cells after a score (using the lastMove data)
                if (gameData.lastMove && gameData.lastMove.scored && gameData.lastMove.cellsToClear && gameData.lastMove.cellsToClear.length > 0) {
                    // Check if this client has already processed this specific move's clearing
                    // We use a simple timestamp check; ideally, use a unique move ID
                    if (!window.lastClearedTimestamp || window.lastClearedTimestamp < gameData.lastMove.timestamp) {
                        window.lastClearedTimestamp = gameData.lastMove.timestamp;

                        // Highlight and clear locally (animation is local, but triggered by Firebase)
                        const cellsToClear = gameData.lastMove.cellsToClear;
                        highlightAndClearCellsMultiplayer(cellsToClear);

                        // Important: The transaction *already* updated the board state in Firebase
                        // to be null for these cells. The listener just needs to update the UI.
                        // We don't need another Firebase update here.
                        // We might need to update the *local* board variable if updateBoardUI doesn't handle nulls properly.
                        // Let's ensure updateBoardUI handles clearing correctly.

                        // Show score message popup
                         const scorer = gameData.lastMove.player;
                         const scorerName = scorer === 'X' ? (isPlayerX ? playerName : opponentName) : (isPlayerX ? opponentName : playerName);
                         const points = gameData.lastMove.cellsToClear.length === 5 ? CONNECT_5_POINTS : CONNECT_4_POINTS;
                         const message = `${scorerName} scores ${points} points!`;
                         // Avoid showing popup if game immediately ended
                         if (!gameOver) {
                              showPopupMessage(message); // Show asynchronously
                         }
                    }
                }

            }, (error) => {
                 console.error("Error listening to game state:", error);
                 // Handle listener error, e.g., show error message, attempt reconnect?
            })]);


            // Listen for opponent disconnect (simplified - relies on player node removal)
            const opponentRole = isPlayerX ? 'O' : 'X';
            const opponentRef = database.ref(`games/${gameId}/players/${opponentRole}`);
            gameListeners.push(['opponentPresence', opponentRef.on('value', (snapshot) => {
                if (!snapshot.exists() && multiplayerGameStarted && !gameOver) { // Check if game was active
                    // Opponent node removed - likely disconnected
                    console.log("Opponent disconnected.");
                    opponentRef.off('value'); // Stop listening to prevent loop if game is deleted later
                    cleanupMultiplayerGame(); // Clean up local listeners
                    showPopupMessage("Your opponent has left the game.")
                        .then(() => resetToLandingPage());
                } else if (snapshot.exists() && !opponentName) {
                     // Update opponent name if it wasn't set initially (e.g., joining player)
                     opponentName = snapshot.val().name;
                     updatePlayerLabels(); // Update labels if needed
                }
            })]);

            // Store the listeners for cleanup
            window.gameListeners = gameListeners;

            // Set presence for automatic cleanup on disconnect
            const playerRole = isPlayerX ? 'X' : 'O';
            database.ref(`games/${gameId}/players/${playerRole}`).onDisconnect().remove()
                 .catch(err => console.error("Failed to set onDisconnect handler:", err)); // Add error handling

            multiplayerGameStarted = true;
            // Ensure opponent name is fetched before initial label update if possible (for joining player)
            const opponentRoleOnInit = isPlayerX ? 'O' : 'X';
            database.ref(`games/${gameId}/players/${opponentRoleOnInit}`).once('value').then(snapshot => {
                 if (snapshot.exists()) {
                     opponentName = snapshot.val().name;
                 }
                 updatePlayerLabels(); // Update labels after potentially fetching opponent name
            });
        }

        function updatePlayerLabels() {
            console.log(`Updating labels. Mode: ${gameMode}, isPlayerX: ${isPlayerX}, playerName: ${playerName}, opponentName: ${opponentName}`); // Debug log
            if (gameMode === 'multiplayer') {
                 const playerXDisplay = isPlayerX ? `${playerName || 'You'} (X)` : `${opponentName || 'Opponent'} (X)`;
                 const playerODisplay = !isPlayerX ? `${playerName || 'You'} (O)` : `${opponentName || 'Opponent'} (O)`;
                 playerXLabel.textContent = playerXDisplay;
                 playerOLabel.textContent = playerODisplay;
            } else {
                 playerXLabel.textContent = 'Player (X)';
                 playerOLabel.textContent = 'Bot (O)';
            }
        }

        // --- Function to handle highlighting and clearing for multiplayer ---
        function highlightAndClearCellsMultiplayer(cells) {
            // 1. Highlight cells locally
            const cellElements = [];
            cells.forEach(({ r, c }) => {
                const cellElement = gameBoardElement.querySelector(`[data-row="${r}"][data-col="${c}"]`);
                if (cellElement) {
                    cellElement.classList.add('highlight');
                    cellElements.push(cellElement);
                }
            });

            // 2. After a delay, remove highlight (cells should already be null in Firebase state)
            setTimeout(() => {
                cellElements.forEach(cellElement => {
                     cellElement.classList.remove('highlight');
                     // The main listener (`updateBoardUI`) should handle clearing the text/class
                     // based on the null value received from Firebase after the transaction.
                });
            }, HIGHLIGHT_DURATION);
        }


        // Modify cleanup to handle new listener structure
        function cleanupMultiplayerGame() {
            console.log("Cleaning up multiplayer game listeners and state...");
            if (window.gameListeners && window.gameListeners.length > 0) {
                const gameRef = database.ref(`games/${gameId}`);
                window.gameListeners.forEach(([type, listener]) => {
                    console.log(`Removing listener for ${type}`);
                    if (type === 'gameState') {
                        gameRef.off('value', listener);
                    } else if (type === 'opponentPresence') {
                         const opponentRole = isPlayerX ? 'O' : 'X';
                         database.ref(`games/${gameId}/players/${opponentRole}`).off('value', listener);
                    }
                    // Add cases here if other specific listeners were added
                });
                window.gameListeners = [];
            }

            // Clear onDisconnect handlers if gameId is known
            if (gameId) {
                const playerRole = isPlayerX ? 'X' : 'O';
                database.ref(`games/${gameId}/players/${playerRole}`).onDisconnect().cancel();

                // If we are player X and the game hasn't officially started (opponent never joined fully)
                // or maybe if the game is over, consider removing the game entry.
                // For simplicity, let's not automatically delete games on disconnect for now.
                // database.ref(`games/${gameId}`).remove(); // Be cautious with this
            }

            // Clear local game state related to multiplayer
            gameId = null;
            multiplayerGameStarted = false;
            isPlayerX = true; // Reset default
            multiplayerTurn = false;
            opponentName = '';
            processingMove = false; // Ensure processing flag is reset
            window.lastClearedTimestamp = null; // Reset clear tracking
        }

        // ... existing code ...

        function resetMultiplayerGame() {
            // Ask for confirmation
            if (!gameId) {
                console.warn("Cannot reset, gameId is null.");
                return;
            }
            if (confirm("Are you sure you want to reset the game? This will restart the score and board for both players.")) {
                console.log(`Player ${playerName} initiated reset for game ${gameId}`);
                // Reset game state in Firebase using an update
                 const initialBoard = Array(GRID_SIZE).fill(null).map(() => Array(GRID_SIZE).fill(null));
                 database.ref(`games/${gameId}`).update({
                    board: initialBoard,
                    currentPlayer: 'X',
                    scores: { X: 0, O: 0 },
                    isRemovalPhase: false,
                    removalTurnsLeft: 0,
                    playerBeforeBoardFull: null,
                    gameOver: false,
                    lastMove: null // Clear last move info
                })
                .then(() => console.log("Game reset successfully in Firebase."))
                .catch(error => console.error("Error resetting game in Firebase:", error));
            }
        }

        // --- Initialization ---
        // ... existing code ...
        
        // Ensure processingMove is initialized
        let processingMove = false; 
        
        // --- Game Logic Functions --- (Keep checkWin, removeSymbol etc. as they might be used by single player)
        
        // Adjust checkWin to be reusable (if needed elsewhere) or rely on checkWinTransaction
        function checkWin(lastRow, lastCol, connectLength) {
            // This function now primarily serves the single-player mode.
            // Multiplayer uses checkWinTransaction inside the transaction.
            const player = board[lastRow][lastCol]; // Uses global board state
            // ... rest of the function remains the same ...
             if (!player) return null;
             const directions = [ { dr: 0, dc: 1 }, { dr: 1, dc: 0 }, { dr: 1, dc: 1 }, { dr: 1, dc: -1 } ];

             for (const { dr, dc } of directions) {
                 let count = 1;
                 let winningCells = [{ r: lastRow, c: lastCol }];
                 for (let i = 1; i < connectLength; i++) {
                     const r = lastRow + i * dr; const c = lastCol + i * dc;
                     if (r >= 0 && r < GRID_SIZE && c >= 0 && c < GRID_SIZE && board[r][c] === player) { count++; winningCells.push({ r, c }); } else break;
                 }
                 for (let i = 1; i < connectLength; i++) {
                     const r = lastRow - i * dr; const c = lastCol - i * dc;
                     if (r >= 0 && r < GRID_SIZE && c >= 0 && c < GRID_SIZE && board[r][c] === player) { count++; winningCells.push({ r, c }); } else break;
                 }
                 if (count === connectLength) { return { cells: winningCells }; }
             }
             return null;
        }


        // ... rest of existing code (single player logic, UI updates etc.) ...

         // --- UI Update Functions ---
        function updateScoreDisplay() {
            scoreXElement.textContent = scores.X || 0; // Handle potential null/undefined scores
            scoreOElement.textContent = scores.O || 0;

            // Highlight active player's score box
            const activePlayer = gameOver ? null : currentPlayer; // Don't highlight if game over
            document.getElementById('player-x-box').classList.toggle('active', activePlayer === 'X');
            document.getElementById('player-o-box').classList.toggle('active', activePlayer === 'O');
        }

        function updateTurnIndicator(overrideText = null) {
            let textToShow = "";
            if (overrideText) {
                textToShow = overrideText;
            } else if (gameOver) {
                 textToShow = "Game Over";
            } else if (gameMode === 'multiplayer') {
                const playerLabel = currentPlayer === 'X' ? (isPlayerX ? 'Your' : opponentName + "'s") : (isPlayerX ? opponentName+"'s" : 'Your');
                const phaseText = isRemovalPhase ? 'Remove: ' : '';
                textToShow = `${phaseText}${playerLabel} Turn`;
                if (processingMove) { // Show thinking state if processing
                    textToShow = "Processing...";
                } else if (!multiplayerTurn && !isRemovalPhase) { // Indicate waiting for opponent
                    textToShow = `Waiting for ${opponentName}...`;
                }
            } else { // Single Player Mode
                 const playerText = currentPlayer === 'X' ? 'Player' : 'Bot';
                 const phaseText = isRemovalPhase ? 'Remove: ' : '';
                 textToShow = `${phaseText}${playerText}'s Turn`;
                 if (currentPlayer === 'O' && !isRemovalPhase) { // Indicate bot thinking in SP
                     // Let triggerAIMove handle "Bot thinking..." message
                 }
            }
            turnIndicatorElement.textContent = textToShow;
        }


        // Ensure updateBoardUI correctly clears cells that become null
        function updateBoardUI(boardState) {
            // console.log("Updating board UI with state:", boardState); // Debug log
            for (let r = 0; r < GRID_SIZE; r++) {
                for (let c = 0; c < GRID_SIZE; c++) {
                    const cell = gameBoardElement.querySelector(`[data-row="${r}"][data-col="${c}"]`);
                    if (!cell) {
                        console.warn(`Cell element not found for row ${r}, col ${c}`);
                        continue; // Skip if cell not found
                    }

                    // Ensure boardState and boardState[r] exist before accessing boardState[r][c]
                    const value = boardState && boardState[r] ? boardState[r][c] : null;

                    // Clear existing classes and content explicitly
                    cell.textContent = '';
                    cell.classList.remove('X', 'O', 'highlight'); // Ensure highlight is removed here too

                    // Add new content if needed
                    if (value === 'X' || value === 'O') {
                        cell.textContent = value;
                        cell.classList.add(value);
                    }
                }
            }
        }
        
        // Remove highlightMultiplayerWin as it's replaced by highlightAndClearCellsMultiplayer
        /*
        function highlightMultiplayerWin(cells) {
            // ... removed ...
        }
        */

        // Remove handleNormalPlayClick and handlePlayerRemovalClick as they are SP only now
        /*
        function handleNormalPlayClick(cell, row, col) {
            // ... removed ...
        }
        function handlePlayerRemovalClick(cell, row, col) {
            // ... removed ...
        }
        */
        
        // Modify initMultiplayerGame to just set up UI listeners and initial state from Firebase
        function initMultiplayerGame() {
            console.log("Initializing Multiplayer Game UI...");
            gameMode = 'multiplayer';
            // Reset local game state variables (will be overwritten by listener)
            board = Array(GRID_SIZE).fill(null).map(() => Array(GRID_SIZE).fill(null));
            currentPlayer = 'X';
            scores = { X: 0, O: 0 };
            gameOver = false;
            isRemovalPhase = false;
            removalTurnsLeft = 0;
            playerBeforeBoardFull = null;
            processingMove = false; // Reset processing flag
            window.lastClearedTimestamp = null; // Reset clear tracking

            // Clear the board UI
            gameBoardElement.innerHTML = '';
            gameBoardElement.removeEventListener('click', handleCellClick); // Ensure SP listener removed
            gameBoardElement.removeEventListener('click', handleMultiplayerCellClick); // Remove previous just in case

            // Create the board cells
            for (let r = 0; r < GRID_SIZE; r++) {
                for (let c = 0; c < GRID_SIZE; c++) {
                    const cell = document.createElement('div');
                    cell.classList.add('cell');
                    cell.dataset.row = r;
                    cell.dataset.col = c;
                    gameBoardElement.appendChild(cell);
                }
            }

            // Add event listener for cell clicks (now points to refactored handler)
            gameBoardElement.addEventListener('click', handleMultiplayerCellClick);

            // Remove old reset listener and add new one
            resetButton.removeEventListener('click', initGame); // Remove SP reset
            resetButton.removeEventListener('click', resetMultiplayerGame); // Remove old MP reset if exists
            resetButton.addEventListener('click', resetMultiplayerGame); // Add new MP reset

            // Set up help button
            helpButton.removeEventListener('click', showInstructions); // Remove old listener
            helpButton.addEventListener('click', showInstructions);

            // Initial UI update (will be refined by listener)
            updateScoreDisplay();
            updateTurnIndicator();
            updateMessage("Waiting for game data...");
            updatePlayerLabels(); // Set player names
        }

        // Ensure initGame correctly sets up for Single Player
        function initGame() {
            console.log("Initializing Single Player Game...");
            gameMode = 'singleplayer';
            cleanupMultiplayerGame(); // Ensure any MP listeners are off

            board = Array(GRID_SIZE).fill(null).map(() => Array(GRID_SIZE).fill(null));
            currentPlayer = 'X';
            scores = { X: 0, O: 0 };
            gameOver = false;
            isRemovalPhase = false;
            removalTurnsLeft = 0;
            playerBeforeBoardFull = null;
            isPlayerTurn = true; // Player X starts
            processingMove = false; // Reset processing flag for SP too
            gameContainerElement.classList.remove('removal-phase');

            gameBoardElement.innerHTML = '';
            gameBoardElement.removeEventListener('click', handleMultiplayerCellClick); // Ensure MP listener removed
            gameBoardElement.removeEventListener('click', handleCellClick); // Remove previous just in case

            for (let r = 0; r < GRID_SIZE; r++) {
                for (let c = 0; c < GRID_SIZE; c++) {
                    const cell = document.createElement('div');
                    cell.classList.add('cell');
                    cell.dataset.row = r;
                    cell.dataset.col = c;
                    gameBoardElement.appendChild(cell);
                }
            }

            gameBoardElement.addEventListener('click', handleCellClick); // Add SP listener

            // Setup Reset button for Single Player
            resetButton.removeEventListener('click', resetMultiplayerGame); // Remove MP reset
            resetButton.removeEventListener('click', initGame); // Remove old SP reset if exists
            resetButton.addEventListener('click', initGame); // Add SP reset

            helpButton.removeEventListener('click', showInstructions);
            helpButton.addEventListener('click', showInstructions);

            // Reset player labels for Single Player
            updatePlayerLabels(); // Use the function to set SP labels too

            updateScoreDisplay();
            updateTurnIndicator();
            updateMessage("");
        }
        
        // Remove the final initGame() call as it's handled by mode selection
        // window.addEventListener('DOMContentLoaded', () => { ... }); // Keep this for initial setup
        // initGame(); // REMOVE THIS LINE 